<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars0.githubusercontent.com/u/16274565?v=3&amp;s=460" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Lirito</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Lirito</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://avatars0.githubusercontent.com/u/16274565?v=3&amp;s=460" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Lirito</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-多项式相加案例" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/07/多项式相加案例/" class="article-date">
  	<time datetime="2017-08-07T08:51:35.662Z" itemprop="datePublished">2017-08-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="多项式相加"><a href="#多项式相加" class="headerlink" title="多项式相加"></a>多项式相加</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code>struct polynode{
    int coef;//系数
    int expon;//指数
    struct polynode *link;//只想下一个节点的指针
};
typedef struct polynode *polynomial;
polynomial p1,p2;

void attach(int c,int e,polynomial *prear){
    polynomial p = (polynomial)malloc(sizeof(struct polynode));
    p-&gt;coef=c;
    p-&gt;expon=e;//指数expon，系数coef
    //将p指向的新节点插入到表达式的后面
    (*prear)-&gt;link=p;
    *prear=p;//修改prear的值
}

polynomial polyadd(polynomial p1,polynomial p2){
    polynomial front,rear,temp;
    int sum;
    rear = (polynomial)malloc(sizeof(struct polynode));
    front=rear;
    while(p1&amp;&amp;p2)
            switch(compare(p1-&gt;expon,p2-&gt;expon)){
                case 1:
                    attach(p1-&gt;coef,p1-&gt;expon,&amp;rear);
                    p1=p1-&gt;link;
                    break;
                case -1:
                    attach(p2-&gt;coef,p2-&gt;expon,&amp;rear);
                    p2=p2-&gt;link;
                    break;
                case 0:
                    sum = p1-&gt;coef+p2-&gt;coef;
                    if(sum) attach(sum,p1-&gt;expon,&amp;rear);
                    p1=p1-&gt;link;
                    p2=p2-&gt;link;
                    break;                    
        }
    for(;p1;p1-&gt;link) attach(p1-&gt;coef,p1-&gt;expon,&amp;rear);//对未处理完的p1将末尾加到表达式后面
    for(;p2;p2-&gt;link) attach(p2-&gt;coef,p2-&gt;expon,&amp;rear);//对未处理完的p2将末尾加到表达式后面

    rear-&gt;link =null;
    temp = front;
    front = front-&gt;link;
    free(temp);
    return front;//返回头指针
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数据结构队列2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/07/数据结构队列2/" class="article-date">
  	<time datetime="2017-08-07T07:09:42.393Z" itemprop="datePublished">2017-08-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据结构之队列"><a href="#数据结构之队列" class="headerlink" title="数据结构之队列"></a>数据结构之队列</h2><h3 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h3><pre><code>typedef struct node *ptnode;
struct node{
    elementtype data;
    ptnode next;
}
typedef ptnode position;

struct qnode{
    position front,rear;
    int maxsize;
}
typedef struct qnode *queue;
</code></pre><p>1.判断队列是否为空</p>
<pre><code>elementtype isempty(queue q){
    return (q-&gt;front==null);
}
</code></pre><p>2.删除一个元素</p>
<pre><code>elementtype deleteq(queue q){
    position frontcell;
    elementtype frontitem;
    if(isempty(q)){
        printf(&quot;队列为空&quot;);
        return error;
    }else{
        frontcell = q-&gt;front;
        if(q-&gt;front==q-&gt;rear)//只有一个元素
            q-&gt;front==q-&gt;rear==null;
        else 
            q-&gt;front=q-&gt;front-&gt;next;

        frontitem = frontcell-&gt;data;

        free(frontcell);
        return frontitem;
    }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数据结构队列1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/04/数据结构队列1/" class="article-date">
  	<time datetime="2017-08-04T09:27:04.922Z" itemprop="datePublished">2017-08-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据结构之队列"><a href="#数据结构之队列" class="headerlink" title="数据结构之队列"></a>数据结构之队列</h2><h3 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h3><pre><code>typedef int position
struct qnode{
    elementtype *data;//存储元素的数组
    position front,rear;//队列的头尾指针
    int maxsize;//队列的最大容量
};
typedef struct qnode *queue; 
</code></pre><p>1.创建一个队列</p>
<pre><code>queue createqueue(int maxszie){
    queue q = (queue)malloc(sizeof(struct qnode));
    q-&gt;data=(elementtype *)malloc(maxsize * sizeo(elementtype));
    q-&gt;front=q-&gt;rear=0;
    q-&gt;maxsize=maxsize;
    return q;
}
</code></pre><p>2.判断队列是否满了</p>
<pre><code>bool isfull(queue q){
    return ((q-&gt;rear+1)%q-&gt;maxsize==q-&gt;front);
}
</code></pre><p>3.判断队列是不是空的</p>
<pre><code>bool isempty(queue q){
    return (q-&gt;front==q-&gt;rear);
}
</code></pre><p>3.加入一个元素到队列里</p>
<pre><code>bool addq(queue q,elementtype item){
    if(isfull(q)){
        printf(&quot;队列满&quot;);
        return false;
    }else{
        q-&gt;rear=(q-&gt;rear+1)%q-&gt;maxsize;
        q-&gt;data[q-&gt;rear] = item;
        return true;
    }
}
</code></pre><p>4.删除队列的一个元素</p>
<pre><code>bool deleteq(queue q){
    if(isempty(q)){
        printf(&quot;队列空&quot;);
        return error;
    }else{
        q-&gt;front=(q-&gt;front+1)%q-&gt;maxsize;
        return q-&gt;data[q-&gt;front];
    }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数据结构堆栈2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/04/数据结构堆栈2/" class="article-date">
  	<time datetime="2017-08-04T08:52:46.192Z" itemprop="datePublished">2017-08-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据结构之堆栈"><a href="#数据结构之堆栈" class="headerlink" title="数据结构之堆栈"></a>数据结构之堆栈</h2><h3 id="堆栈的链式存储"><a href="#堆栈的链式存储" class="headerlink" title="堆栈的链式存储"></a>堆栈的链式存储</h3><p>1.定义一个结构体</p>
<pre><code>typedef struct snode *stack;
struct snode{
    elementtype data;
    struct snode *next;
};
</code></pre><p>2.堆栈初始化</p>
<pre><code>stack createstack(){
    stack s;
    s=(stack)malloc(sizeof(struct snode));
    s-&gt;next = null;
    return s;
}
</code></pre><p>3.判断堆栈s是否为空</p>
<pre><code>int isempty(stack s){
    return (s-&gt;next==null);
}
</code></pre><p>4.插入一个数据</p>
<pre><code>void push(stack s,elementtype item){
    struct snode *tmpcell;
    tmpcell=(stack)malloc(sizeof(struct snode));
    tmpcell-&gt;data = item;
    tmpcell-&gt;next = s-&gt;next;
    s-&gt;next=tmpcell;
}
</code></pre><p>5.删除一个数据</p>
<pre><code>elementtype pop(stack s){
    struct snode *a;
    elementtype item;//保存删除的数据
    if(isempty(s)){
        printf(&quot;栈为空&quot;)；
    }else{
        a=s-&gt;next;
        s-&gt;next = a-&gt;next;
        item = a-&gt;data;
        free(a);
        return item;
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数据结构堆栈1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/03/数据结构堆栈1/" class="article-date">
  	<time datetime="2017-08-03T07:46:49.477Z" itemprop="datePublished">2017-08-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据结构之堆栈（数组）"><a href="#数据结构之堆栈（数组）" class="headerlink" title="数据结构之堆栈（数组）"></a>数据结构之堆栈（数组）</h2><h3 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h3><p>1.定义一个结构体</p>
<pre><code>#define maxsize //保存数组元素的最大个数
typedef struct snode *stack;
struct snode{
    elementtype data[maxsize];
    int top;
};
</code></pre><p>2.入栈操作</p>
<pre><code>void push(stack ptrs,elementtype item){
    if(ptrs-&gt;top==maxsize-1){
        printf(&quot;堆栈满&quot;);return;
    else{
        ptrs-&gt;dat[++(ptrs-&gt;top)]=item;
    return;
    }
}
</code></pre><p>3.出栈操作</p>
<pre><code>elementtype pop(stack ptrs){
    if(ptrs-&gt;top==-1){
        printf(&quot;堆栈空&quot;); return error;
    }else return (ptrs-&gt;data[(ptrs-&gt;top)--]);
}
</code></pre><h3 id="用一个数组实现两个堆栈"><a href="#用一个数组实现两个堆栈" class="headerlink" title="用一个数组实现两个堆栈"></a>用一个数组实现两个堆栈</h3><p>1.定义一个结构体</p>
<pre><code>#define maxsize //保存数组元素最大个数
typedef struct snode *s
struct snode{
    elementtype data[maxsize];
    int top1;
    int top2;
};
</code></pre><p>2.入栈操作</p>
<pre><code>void push(s ptrs,elementtype item,int tag){
    if(ptrs-&gt;top2-ptrs-&gt;1==1){
        printf(&quot;堆栈满&quot;);return;
    }
    if(tag==1){
        ptrs-&gt;data[++(ptrs-&gt;top1)]=item;
    }else{
        ptrs-&gt;data[--(ptrs-&gt;top2)]==item;
    }
}
//tag作为区分两个堆栈的标志，取值为0或1
</code></pre><p>3.出栈操作</p>
<pre><code>elementtype pop(s ptrs,int tag){
    if(tag == 1){
        if(ptrs-&gt;top==-1){
            printf(&quot;堆栈1空&quot;);return null;
        }else return ptrs-&gt;data[(ptrs-top1)--];
    }else {
        if(ptrs-&gt;top==maxsize){
            printf(&quot;堆栈2空&quot;);return null;
        }else return ptrs-&gt;data[(ptrs-&gt;top2)++];
    }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数据结构线性表2.2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/07/22/数据结构线性表2.2/" class="article-date">
  	<time datetime="2017-07-22T07:41:39.040Z" itemprop="datePublished">2017-07-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据结构之线性表"><a href="#数据结构之线性表" class="headerlink" title="数据结构之线性表"></a>数据结构之线性表</h2><h3 id="线性表的链式存储实现"><a href="#线性表的链式存储实现" class="headerlink" title="线性表的链式存储实现"></a>线性表的链式存储实现</h3><p>1.定义一个结构体</p>
<pre><code>typedef struct lnode *list;
struct lnode{
    elementtype data;
    list next;
};
struct lnode l;
list ptrl;
</code></pre><p>2.求表长</p>
<pre><code>int length(list ptrl){
list p = ptrl;//头结点
int j=0;
while(p)
{
    p=p-&gt;next;
    j++;
}
return j;
}
</code></pre><p>3.查找</p>
<p>（1）按序号查找：findkth</p>
<pre><code>int findkth(list ptrl,int k){
    list p = ptrl;
    int j=1;
    while((p!=null)&amp;&amp;(j&lt;k)){
        p=p-&gt;next;
        j++;
    }
    if(j==k) return p;//找到了，返回指针p
    else return null;//否则返回空
}
</code></pre><p>（2）按值查找：find</p>
<pre><code>int find(list ptrl,elementtype x){
    list p = ptrl;
    while(p!=null&amp;&amp;p-&gt;data!=x)
        p=p-&gt;next;
    return p;
}
</code></pre><p>4.插入（在第i-1(l&lt;=i&lt;=n+1)个结点后插入一个值为x的新结点）</p>
<p>思路：1.先构造一个新节点，用s指向。 2.找到链表的第i-1个结点，用p指向 3.修改指针，插入结点</p>
<pre><code>list insert(list ptrl,elementtype x,int i){
    list p,s;
    if(i==1){
        s=(list)malloc(sizeof(struct lnode));
        s-&gt;next = ptrl;
        s-&gt;data = x;
        return s;//返回新表头指针
    }
    p = findkth(ptrl,i-1);//找到第i-1个结点
    if(p==null){
        printf(&quot;未找到结点，参数i错误&quot;);
    return null;
    }
    else {
        s=(list)malloc(sizeof(struct lnode));
        s-&gt;next = p-&gt;next;
        p-&gt;next = s;
        s-&gt;data=x;
        return ptrl;
    }
}
</code></pre><p>5.删除（删除链表的第i(l&lt;=i&lt;=n)个位置上的结点)</p>
<p>思路：1.先找到链表第i-1个位置的结点，用p指向 2.找到要删除的结点，用s指向 3.修改指针，删除s结点 4.释放s结点的空间</p>
<pre><code>list delete(list ptrl,int i){
    list p,s;
    if(i==1){
        s=ptrl;
        if(ptrl!=null) ptrl = ptrl-&gt;next;
        else return null;
        free(s);
        return ptrl;
    }
    p=findkth(ptrl,i-1);
    if(p==null){
        printf(&quot;第%d个结点不存在&quot;,i-1);  return null;
    }else if(p-&gt;next == null){ 
        printf(&quot;第%d个结点不存在&quot;,i);   return null;
    }else {
        s=p-&gt;next;
        p-&gt;next = s-&gt;next;
        free(s);
        return ptrl;
        }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数据结构线性表2.1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/07/20/数据结构线性表2.1/" class="article-date">
  	<time datetime="2017-07-20T07:25:16.539Z" itemprop="datePublished">2017-07-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据结构之线性表"><a href="#数据结构之线性表" class="headerlink" title="数据结构之线性表"></a>数据结构之线性表</h2><h4 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现"></a>线性表的顺序存储实现</h4><p>1 定义一个结构体</p>
<pre><code>typedef struct lnode *list;
struct lnode{
    elementtype data[maxsize];
    int last;
};
struct lnode l;//声明一个l的表
list ptrl;//声明一个ptrl的表
</code></pre><p>线性表的长度：l.last+1或者ptrl-&gt;last+1（0~n）</p>
<p>访问线性表的元素：l.data[i]或者ptrl-&gt;data[i]</p>
<p>2 对线性表的一些基本操作</p>
<ul>
<li><p>初始化（建立一个空的线性表） </p>
<pre><code>list initialize(){
    list ptrl;
    ptrl = (list)malloc(sizeof(struct lnode));
    ptrl-&gt;last = -1;//尾指针指向-1，代表这是个空链表
    return ptrl;//返回链表ptrl
}
</code></pre></li>
<li><p>查找</p>
<pre><code>int find(elementtype X,list ptrl){
    int i=0;
    while((i&lt;=ptrl-&gt;last)&amp;&amp;(ptrl-&gt;data[i]!=X))
        i++;
    if(i&gt;ptrl-&gt;last) return -1;//当超出链表长度的时候返回错误
    else 
    return i;//找到返回数组下标，即存储位置
    }
</code></pre></li>
<li><p>插入（第i(l&lt;=i&lt;=n+1)个位置上插入一个值为X的新元素）</p>
<pre><code>void insert(elementtype X,int i,list ptrl){
    //传入数据X，下标i
    //注意插入位置的合法性，以及表满表空。
    int j;

    if(ptrl-&gt;last = maxsize-1){//判断是否表满，相当于ptrl-&gt;last+1=maxsize;
    printf(&quot;表满&quot;);
    return;
    }

    if(i&lt;1||i&gt;ptrl-&gt;last+2){
    printf(&quot;位置不合法&quot;)；
    return;
    }

    for(j = i-1;j&lt;ptrl-&gt;last+2;j++)
        ptrl-&gt;data[j+1] = ptrl-&gt;data[j];//倒序插入
    ptrl-&gt;data[i-1]=X;
    ptrl-&gt;last++;//将指针移动到下一位，也就是末尾
    return;
}
</code></pre><p>注意：再插入一个数据的时候，需要先把最后面的数据插入到前面一个数据，不然从前面插入会与后面的数据冲突</p>
</li>
<li><p>删除（删除表的第i(l&lt;=i&lt;=n)个位置上的元素)</p>
<pre><code>void delete(int i,list ptrl){
    //传入要删除的数的下标
    list ptrl;
    int j;

    if(i&lt;1||i&gt;ptrl-&gt;last+1){//检查空表及删除位置的合法性
    printf(&quot;不存在第%d的元素&quot;，i)；
    return;
    }

    for(j=i;j&lt;=ptrl-&gt;last;j++)
        ptrl-&gt;data[j-1]=ptrl-&gt;data[j];     
    ptrl-&gt;last--;
    return;
    }
</code></pre></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-自学unity(二)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/08/自学unity(二)/" class="article-date">
  	<time datetime="2017-05-08T15:50:35.860Z" itemprop="datePublished">2017-05-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="GUI游戏界面"><a href="#GUI游戏界面" class="headerlink" title="GUI游戏界面"></a>GUI游戏界面</h2><h4 id="GUI高级控件"><a href="#GUI高级控件" class="headerlink" title="GUI高级控件"></a>GUI高级控件</h4><p>1.Label控件</p>
<p>作用：可以在游戏界面中以文本的形式展示出一段字符串信息。</p>
<p>注意事项：编码格式修改为（utf-8），否则中文显示不出来。</p>
<p>方法：Start()方法，只执行一次，需将所有初始化的相关代码都放在此方法内。OnGUI()方法，界面绘制方法，所有GUI的绘制都需要在这个方法中实现</p>
<p>代码示例：</p>
<pre><code>//接受外部赋值字符串
var str : String;
//接受外部赋值贴图
var imageTexture : Texture;
//贴图宽度
private var imageWidth : int;
//贴图高度
private var imageHeight : int;
//当前屏幕宽度
private var screenWidth : int;
//当前屏幕高度
private var screenHeight : int;

fuction Start()
{
    //得到屏幕宽高
    screenWidth = Screen.width;
    screenHeight = Screen.height;
    //得到图片宽高
    imageWidth = imageTexture.width;
    imageHeight = imageTexture.height;
}

fuction OnGUI()
{
    //将文字内容显示在屏幕中
    GUI.Label(Rect(100,10,100,30),str);
    GUI.Label(Rect(100,40,100,30),&quot;当前屏幕高：&quot; + screenHeight);
    GUI.Label(Rect(100,80,100,30),&quot;当前屏幕宽：&quot; + screenWidth);
    //将贴图显示在屏幕中
    GUI.Label(Rect(100,120,imageWidth,imageHeight),imageTexture);
}
</code></pre><p>2.Button控件</p>
<p>作用：判断用户在程序中的一些操作行为。</p>
<p>注意事项：按钮共有三个基本状态：未点击状态、击中状态、点击后状态。按展现方式分为普通按钮和图片按钮。</p>
<p>方法：GUI.Button()方法添加一个按钮，当该方法返回true时，表示按钮被按下。GUI.RepeatButton()方法可添加一个连续按钮，用于监听该按钮按下中的状态。</p>
<pre><code>//按钮贴图
var buttonTexture : Texture2D;
//提示信息
var str : String;
//时间计数器
private var frameTime : int;

fuction Start()
{
        //初始化赋值
        str = &quot;请您点击按钮&quot;;
}

fuction OnGUI()
{
    //显示信息提示内容
    GUI.Label(Rect(10,10,Screen.width,30),str);
    if(GUI.Button(Rect(10,50,buttonTexture.width,buttonTexture.height),buttonTexture)){
        //点击按钮修改提示信息
        str = &quot;您点击了图片按钮&quot;;
    }
    //设置按钮中文字的颜色
    GUI.color  = Color.green;
    //设置按钮的背景色
    GUI.backgroundColor = Color.red;

    if(GUI.Button(Rect(10,200,70,30),&quot;文字按扭&quot;)){
        //点击按钮修改提示信息
        str = &quot;您点击了文字按钮&quot;;
    }
    //设置按钮中文字的颜色
    GUI.color  = Color.yellow;
    //设置按钮的背景色
    GUI.backgroundColor = Color.black;

    if(GUI.RepeatButton(Rect(10,250,100,30),&quot;按钮按下中&quot;)){
        //点击按钮修改提示信息
        str = &quot;按钮按下中的时间：&quot; + frameTime;
        //时间计数器
        frameTime++;
    }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-博客的一些注意事项" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/08/博客的一些注意事项/" class="article-date">
  	<time datetime="2017-05-08T15:10:13.940Z" itemprop="datePublished">2017-05-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1.上传一个新的文档：hexo g;hexo d;</p>
<p>2.访问自己博客地址：注意是字母大小写，与github项目上项目名称一样。</p>
<p>3.本地观看效果：hexo s;</p>
<p>4.markdown标题格式后面加个空格，格式如“### 你好”。否则hexo辨别不出</p>
<p>5.代码块的部分需要缩进4个空格或是一个制表符。</p>
<p>6.无序列表直接使用星号，加号或减号作为列表标记，注意打完字符后需要加空格，有序列表直接使用数字，后面加空格。</p>
<p>7.加图片的格式：![图片的替代文字] (图片地址)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-自学unity(一)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/04/自学unity(一)/" class="article-date">
  	<time datetime="2017-05-04T11:52:57.443Z" itemprop="datePublished">2017-05-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自学unity（一）"><a href="#自学unity（一）" class="headerlink" title="自学unity（一）"></a>自学unity（一）</h2><h3 id="project视图"><a href="#project视图" class="headerlink" title="project视图"></a>project视图</h3><p>作用：主要存放游戏中所需要用到的资源文件。包括游戏脚本，预设，材质，自定义字体等。这些可以赋值给游戏对象。</p>
<h3 id="hierarchy视图"><a href="#hierarchy视图" class="headerlink" title="hierarchy视图"></a>hierarchy视图</h3><p>作用：主要存放游戏场景中具体的游戏对象，比如摄像机，平面贴图，3d贴图，光源等。</p>
<h3 id="inspector视图"><a href="#inspector视图" class="headerlink" title="inspector视图"></a>inspector视图</h3><p>作用：可以展示对象的具体信息，比如说位置什么的，存放游戏对象，游戏资源，游戏设置以及描述信息的地方。</p>
<h3 id="scene视图"><a href="#scene视图" class="headerlink" title="scene视图"></a>scene视图</h3><ol>
<li>作用：存放游戏中的模型资源。比如主角，敌人等。</li>
<li><p>某些功能：移动模型</p>
<pre><code>function Update()
{ 
//移动模型
transform.Translate(Vector3.forward * Time.deltaTime);
}
</code></pre></li>
</ol>
<p>transform.Translate()方法用于设置游戏对象平移的方向。Vector3.forward表示移动的方向为前方，Time.deltaTime表示Update()方法上一帧持续的时间，这两个的乘机就是前方模型一次移动的距离。</p>
<p>此外还有旋转模型，缩放模型等。</p>
<h3 id="game视图"><a href="#game视图" class="headerlink" title="game视图"></a>game视图</h3><p>作用：可在此视图中运行游戏，不过其显示的内容完全取决于摄像机所照射的部分。</p>
<h3 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h3><p>导出：选择Assets-&gt;Export Package菜单项。</p>
<p>导入：直接双击“.unitypackage”游戏工程包。</p>
<h2 id="第一个游戏实例"><a href="#第一个游戏实例" class="headerlink" title="第一个游戏实例"></a>第一个游戏实例</h2><p>代码脚本如下，其中解释：OnGUI()用于绘制GUI界面组件。Rect表示规定一个矩形区域，用于显示控件。Vector3标志一个模型旋转移动的方向。transform.Rotate()设置模型旋转，transform.Translate()设置模型平移。GUI.Button()设置一个按钮，返回true时按钮被按下。GUI.Label()设置一个文本框。</p>
<pre><code>#pragma strict
//模型移动速度
var TranslateSpeed = 20;
//模型旋转速度
var RotateSpeed = 1000;
//绘制UI
function OnGUI () {
//设置GUI背景颜色
GUI.backgroundColor = Color.red;
if(GUI.Button(Rect(10,10,70,30), &quot;向左旋转&quot;))
{
 //向左旋转模型
 transform.Rotate(Vector3.up * Time.deltaTime * (-RotateSpeed));
}

if(GUI.Button(Rect(90,10,70,30), &quot;向前移动&quot;))
{
 //向前移动模型
 transform.Translate(Vector3.forward * Time.deltaTime * TranslateSpeed);
}
if(GUI.Button(Rect(170,10,70,30), &quot;向右旋转&quot;))
{
 //向右旋转模型
 transform.Rotate(Vector3.up * Time.deltaTime * (RotateSpeed));
}
if(GUI.Button(Rect(90,50,70,30), &quot;向后移动&quot;))
{
 //向后移动模型
 transform.Rotate(Vector3.forward * Time.deltaTime * (-TranslateSpeed));
}
if(GUI.Button(Rect(10,50,70,30), &quot;向左移动&quot;))
{
 //向左移动模型
 transform.Translate(Vector3.right * Time.deltaTime * (-TranslateSpeed));
}
if(GUI.Button(Rect(170,50,70,30), &quot;向右移动&quot;))
{
 //向右移动模型
 transform.Translate(Vector3.right * Time.deltaTime * (TranslateSpeed));
}

//显示模型位置信息
GUI.Label(Rect(250,10,200,30),&quot;模型的位置&quot; + transform.position);
//显示模型旋转信息
GUI.Label(Rect(250,50,200,30),&quot;模型的旋转&quot; + transform.rotation);
}
</code></pre><p>最后为其中一个模型设置一个刚体(Rigidbody)属性。从Component到Physics到Rigidbody。</p>
<p>至此，一个游戏实例就完成了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Lirito
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>